<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 32feet.net 蓝牙虚拟串口编程 · 碎片</title><meta name="description" content="32feet.net 蓝牙虚拟串口编程 - tisyang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tisyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">32feet.net 蓝牙虚拟串口编程</h1><div class="post-info">2016年5月27日</div><div class="post-content"><p>Windows 上的蓝牙编程并不方便，由于操作系统并没有提供统一的蓝牙操作接口，通常是由各个蓝牙设备商提供蓝牙栈，所以要想编程兼容这些不同的厂商蓝牙是一个问题。好在有个软件项目 <a href="http://32feet.codeplex.com/" title="32feet.NET" target="_blank" rel="external">32feet.NET</a> 针对主流蓝牙协议栈提供了支持，包括 Microsfot, Widcomm, BlueSolei 等，同时还支持红外传输协议。</p>
<p>蓝牙虚拟串口是一个较为常见的需求，为了兼容已有使用串口设备的程序，需要将蓝牙连接转为系统上的虚拟串口，然后提供给其他程序或库使用。<a href="http://32feet.codeplex.com/" title="32feet.NET" target="_blank" rel="external">32feet.NET</a> 对此也提供了支持。</p>
<a id="more"></a>
<p><a href="http://32feet.codeplex.com/" title="32feet.NET" target="_blank" rel="external">32feet.NET</a> 依赖 .NET 3.5 版本以上框架，支持 Windows 桌面版本、Wndows CE 以及 Windows Phone。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果使用 Visual Studio 2015 或者 安装有 NuGet 工具的，可以直接通过 NuGet 安装。在 NuGet 命令行中输入</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package <span class="number">32</span>feet.NET</span><br></pre></td></tr></table></figure>
<p>这样 NuGet 会自动下载安装并添加到当前 .NET 项目中。可以检查项目 <code>References</code> 项，如果存在 <code>InTheHand.Net.Personal</code> 则表明已成功加入到项目中，如果没有，可以手动添加引用，NuGet 下载存放在 <code>SolutionName\packages\32feet.NET.x.x.x.x\</code> 路径下。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面主要讲解 <a href="http://32feet.codeplex.com/" title="32feet.NET" target="_blank" rel="external">32feet.NET</a> 的使用，覆盖蓝牙搜索、配对、直接连接以及虚拟串口服务。</p>
<h3 id="1-检测系统蓝牙可用性"><a href="#1-检测系统蓝牙可用性" class="headerlink" title="1. 检测系统蓝牙可用性"></a>1. 检测系统蓝牙可用性</h3><p>如果系统没有蓝牙设备或者蓝牙设备被禁用，那么可以通过以下函数来进行检查：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPlatformSupportBT</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    BluetoothClient bc;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        bc = <span class="keyword">new</span> BluetoothClient();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (PlatformNotSupportedException)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bc.Close();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果系统不支持蓝牙设备，那么 <code>new BluetoothClient</code> 会抛出 <code>PlatformNotSupportedException</code> 异常，通过捕获这个异常，来检测系统蓝牙设备可用性。</p>
<h3 id="2-蓝牙搜索"><a href="#2-蓝牙搜索" class="headerlink" title="2. 蓝牙搜索"></a>2. 蓝牙搜索</h3><p><code>BluetoothClient</code> 对象有个方法 <code>DiscoverDevices</code> 用于搜索蓝牙设备，该方法有多个重载版本，最终都是调用如下这个接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BluetoothDeviceInfo[] <span class="title">DiscoverDevices</span>(<span class="params"><span class="keyword">int</span> maxDevices, <span class="keyword">bool</span> authenticated, <span class="keyword">bool</span> remembered, <span class="keyword">bool</span> unknown, <span class="keyword">bool</span> discoverableOnly</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数表明搜索的最大设备数，第二个参数表示是否搜索已配对设备，第三个表示是否搜索记住的设备，第四个表示是否搜索未知设备，第五个参数表示是搜索范围内可被发现的设备。</p>
<p>这里面重要的是第二和第五个参数，第二个代表搜索系统中已配对列表中的设备，即使它们现在并不在线。第五个参数 XP 系统上不支持，表示搜索范围内可被发现的设备。</p>
<p>如果我们需要获得系统中已配对列表中的蓝牙设备，可以这样调用 <code>DiscoverDevices(255, true, false, false)</code>，这里使用了4个参数的重载版本，只将第二个参数置为 <code>true</code>。</p>
<p>如果我们需要搜索周围环境中可用的蓝牙设备，可以这样调用 <code>DiscoverDevices(255, false, false, false, true)</code>，这个调用等同于 <code>DiscoverDevicesInRange()</code>。</p>
<p>需要注意的是，这个调用是同步阻塞的，在搜索没有结束之前函数不会返回。所以通常我们需要将这个调用放入工作线程中。例外的是，如果只是获取系统中已配对列表中的设备，这个调用会很快完成，不会占用当前线程太多时间。</p>
<p>库中同时提供了一个异步搜索方法，由类 <code>BluetoothComponent</code> 提供，由事件 <code>DiscoverDevicesProgress</code> 和 事件 <code>DiscoverDevicesComplete</code> 以及方法 <code>DiscoverDevicesAsync</code> 来实现。这个和用 <code>BackgroundWorker</code> 来实现 <code>DiscoverDevices()</code> 异步查找是一样的。</p>
<p>PS: 可以通过 VS 的 Object Browser 查看 <code>InTheHand.Net.Personal</code> 库中的函数接口说明，说明非常翔实。</p>
<h3 id="3-检测蓝牙设备是否在范围内"><a href="#3-检测蓝牙设备是否在范围内" class="headerlink" title="3. 检测蓝牙设备是否在范围内"></a>3. 检测蓝牙设备是否在范围内</h3><p>当需要检查一个蓝牙设备是否在有效范围内，可以通过查询一个 Fake Service ID 来实现。</p>
<p>如果蓝牙设备在范围内可访问，那么查询的结果是返回的服务记录为空，表示不支持此服务；如果蓝牙设备不在范围内，那么会抛出套接字异常。</p>
<p>以下为检测代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TestingIfInRange</span>(<span class="params">BluetoothAddress addr</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> inRange = <span class="literal">false</span>;</span><br><span class="line">    Guid fakeUuid = <span class="keyword">new</span> Guid(<span class="string">"&#123;F13F471D-47CB-41d6-9609-BAD0690BF891&#125;"</span>);</span><br><span class="line">    BluetoothDeviceInfo device = <span class="keyword">new</span> BluetoothDeviceInfo(addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ServiceRecord[] records = device.GetServiceRecords(fakeUuid);</span><br><span class="line">        Debug.Assert(records.Length == <span class="number">0</span>, <span class="string">"Why are we getting any records? len: "</span> + records.Length);</span><br><span class="line">        inRange = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SocketException)</span><br><span class="line">    &#123;</span><br><span class="line">        inRange = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inRange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为蓝牙设备通信需要时间，所以这个调用也需要较长时间才能完成，未完成之前进入阻塞不返回，所以这个方法也需要放入工作线程中执行。</p>
<p>这部分内容可以参考官方文档： <a href="http://32feet.codeplex.com/wikipage?title=Testing%20if%20a%20device%20is%20in%20range" title="Testing if a device is in range" target="_blank" rel="external">Tesing if a device is in rage</a>.</p>
<h3 id="4-蓝牙设备配对"><a href="#4-蓝牙设备配对" class="headerlink" title="4. 蓝牙设备配对"></a>4. 蓝牙设备配对</h3><p>蓝牙配对功能由类 <code>BluetoothSecurity</code> 的静态方法 <code>PairRequest(BluetoothAddress device, string pin)</code> 提供，其中第一个参数是目标设备地址，第二个参数是用于配对的 Pin 码。配对成功返回 <code>true</code>，失败返回 <code>false</code>。</p>
<p>解除配对是 <code>BluetoothSecurity.RemoveDevice(BluetoothAddress device)</code> 。</p>
<p>配对操作也需要将长时间完成，所以这个方法也需要放入工作线程中执行。</p>
<h3 id="5-蓝牙直接连接"><a href="#5-蓝牙直接连接" class="headerlink" title="5. 蓝牙直接连接"></a>5. 蓝牙直接连接</h3><p>如果不需要蓝牙虚拟串口而直接读写蓝牙数据，那么可以使用直接连接，这个可以参照官方文档：<a href="http://32feet.codeplex.com/wikipage?title=General%20Bluetooth%20Data%20Connections" title="General Bluetooth Data Connections" target="_blank" rel="external">General Bluetooth Data Connections</a>.</p>
<p>通过直接连接获取一个可读写的 <code>System.IO.Stream</code> 流对象，就可以直接对蓝牙进行读写数据操作了。以下为官方样例中的代码</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAddress addr = BluetoothAddress.Parse(<span class="string">"001122334455"</span>);</span><br><span class="line">Guid serviceClass;</span><br><span class="line">serviceClass = BluetoothService.SerialPort;</span><br><span class="line"><span class="comment">// - or - etc</span></span><br><span class="line"><span class="comment">// serviceClass = MyConsts.MyServiceUuid</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> ep = <span class="keyword">new</span> BluetoothEndPoint(addr, serviceClass);</span><br><span class="line"><span class="keyword">var</span> cli = <span class="keyword">new</span> BluetoothClient();</span><br><span class="line">cli.Connect(ep);</span><br><span class="line">Stream peerStream = cli.GetStream();</span><br><span class="line"><span class="comment">// peerStream.Write/Read ...</span></span><br></pre></td></tr></table></figure>
<h3 id="6-蓝牙虚拟串口"><a href="#6-蓝牙虚拟串口" class="headerlink" title="6. 蓝牙虚拟串口"></a>6. 蓝牙虚拟串口</h3><p>这部分讲解如何实现将蓝牙连接转为系统上的虚拟串口并获取串口名，还可以参阅官方文档： <a href="http://32feet.codeplex.com/wikipage?title=Bluetooth%20Serial%20Ports" title="Bluetooth Seiral Ports" target="_blank" rel="external">Bluetooth Serial Ports</a>.</p>
<p>首先需要说明的是，虚拟串口和直接连接数据读写不同同时使用，如果已经使用了其中一个方法进行读写，那么另外的一个方法会失败。</p>
<p>生成虚拟串口需要将蓝牙设备服务设置为 <code>BluetoothService.SerialPort</code>，官方样例代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BluetoothAddress addr = BluetoothAddress.Parse(<span class="string">"123456789012"</span>);</span><br><span class="line">BluetoothDeviceInfo device = <span class="keyword">new</span> BluetoothDeviceInfo(addr);  <span class="comment">// Or from discovery etc</span></span><br><span class="line"><span class="keyword">bool</span> state = <span class="literal">true</span>;</span><br><span class="line">device.SetServiceState(BluetoothService.SerialPort, state, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><code>SetServiceState</code> 的第一个函数表示服务标识，第二个表示要设置的服务状态，<code>true</code> 为启用， <code>false</code> 为禁用，第三个参数表示如果设置失败是否抛出异常。</p>
<p>但在实际使用中，某些双模蓝牙在设置时，虽然设置成功但是依然会抛出 <code>Win32Exception</code> 异常，所以这里建议调用此函数的重载版本 <code>SetServiceState(System.Guid service, bool state)</code>，而想要知道是否设置成功，下面会介绍其他方法来获得。</p>
<p>这个方法调用并不会告诉我们新生成的串口名，官方文档中的建议是通过设置前后的系统串口列表差异来获取新生成的串口名，而获取系统串口列表则可以调用静态方法 <code>SerialPort.GetPortNames</code>。</p>
<p>但是不建议用这个方法来获取虚拟串口名，因为这个不可靠而且容易出错，下面介绍另外一个可靠方法，而且这个方法也可以同时告诉我们设置虚拟串口服务是否成功。</p>
<h4 id="获取蓝牙虚拟串口名"><a href="#获取蓝牙虚拟串口名" class="headerlink" title="获取蓝牙虚拟串口名"></a>获取蓝牙虚拟串口名</h4><p>这部分参阅官方文档：<a href="http://32feet.codeplex.com/wikipage?title=Getting%20Virtual%20COM%20Port%20Names" title="Getting Virtual COM Port Names for Remote Bluetooth Devices" target="_blank" rel="external">Getting Virtual COM Port Names for Remote Bluetooth Devices</a>.</p>
<p>蓝牙虚拟串口在系统中都有记录，我们可以通过检索这个记录，来找到所设置的设备的虚拟串口名，同时也可以得知我们的蓝牙虚拟串口是否设置成功。</p>
<p>通过调用 WMI 查询，可以枚举出系统中每个串口的详细信息。这里可以通过 PowerShell 来查询：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; <span class="built_in">Get-WmiObject</span> -query <span class="string">"select DeviceID,PNPDeviceID from Win32_SerialPort"</span></span><br></pre></td></tr></table></figure>
<p>输出样例（其中 <code>COM66</code> 对应的蓝牙设备地址为 <code>00803A686519</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DeviceID     : COM66</span><br><span class="line">PNPDeviceID  : BTHENUM\&#123;00001101-0000-1000-8000-00805F9B34FB&#125;\7&amp;1D80ECD3&amp;0&amp;00803A686519_C00000003</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>可以看出蓝牙虚拟串口的 <code>PNPDeviceID</code> 是以 <code>BTHENUM</code> 开头，并且会将蓝牙地址存放其中。</p>
<p>这个查询也可以通过 C# 代码实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Management;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">string</span> Win32_SerialPort = <span class="string">"Win32_SerialPort"</span>;</span><br><span class="line">SelectQuery q = <span class="keyword">new</span> SelectQuery(Win32_SerialPort);</span><br><span class="line">ManagementObjectSearcher s = <span class="keyword">new</span> ManagementObjectSearcher(q);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">object</span> cur <span class="keyword">in</span> s.Get()) &#123;</span><br><span class="line">    ManagementObject mo = (ManagementObject)cur;</span><br><span class="line">    <span class="keyword">object</span> id = mo.GetPropertyValue(<span class="string">"DeviceID"</span>);</span><br><span class="line">    <span class="keyword">object</span> pnpId = mo.GetPropertyValue(<span class="string">"PNPDeviceID"</span>);</span><br><span class="line">    console.WriteLine(<span class="string">"DeviceID:    &#123;0&#125; "</span>, id);</span><br><span class="line">    console.WriteLine(<span class="string">"PNPDeviceID: &#123;0&#125; "</span>, pnpId);</span><br><span class="line">    console.WriteLine(<span class="string">""</span>);</span><br><span class="line">&#125;<span class="comment">//for</span></span><br></pre></td></tr></table></figure>
<p>综上，我们可以定义一个函数，这个函数通过 WMI 检索所有串口设备信息，然后返回一个 <code>Hashtable</code>，其中存储的键为蓝牙设备地址，存储的值为串口名。</p>
<p>函数定义如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hashtable <span class="title">QueryBTHPorts</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">string</span> Win32_SerialPort = <span class="string">"Win32_SerialPort"</span>;</span><br><span class="line">    SelectQuery q = <span class="keyword">new</span> SelectQuery(Win32_SerialPort);</span><br><span class="line">    ManagementObjectSearcher s = <span class="keyword">new</span> ManagementObjectSearcher(q);</span><br><span class="line"></span><br><span class="line">    Hashtable hashResult = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">object</span> cur <span class="keyword">in</span> s.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        ManagementObject mo = (ManagementObject)cur;</span><br><span class="line">        <span class="keyword">string</span> id = mo.GetPropertyValue(<span class="string">"DeviceID"</span>).ToString();</span><br><span class="line">        <span class="keyword">string</span> pnpId = mo.GetPropertyValue(<span class="string">"PNPDeviceID"</span>).ToString();</span><br><span class="line">        Debug.WriteLine(<span class="string">"WMI&gt;&gt;DeviceID: "</span> + id);</span><br><span class="line">        Debug.WriteLine(<span class="string">"WMI&gt;&gt;PNPDeviceID: "</span> + pnpId);</span><br><span class="line">        Debug.WriteLine(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 仅处理蓝牙串口 */</span></span><br><span class="line">        <span class="keyword">if</span> (pnpId.StartsWith(<span class="string">"BTHENUM"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 从 PNPDeviceID 中提取出蓝牙地址，策略是逆序字符串  &amp; 后 _ 之前 */</span></span><br><span class="line">            <span class="comment">/* 蓝牙地址为6字节，HEX为12位字符 */</span></span><br><span class="line">            <span class="keyword">int</span> rBound = pnpId.LastIndexOf(<span class="string">'_'</span>);</span><br><span class="line">            <span class="keyword">int</span> lBound = pnpId.LastIndexOf(<span class="string">'&amp;'</span>);</span><br><span class="line">            Debug.Assert(rBound - lBound == <span class="number">13</span>, <span class="string">"Get BT Addr, this will nevery happened."</span>);</span><br><span class="line">            <span class="keyword">string</span> addr = pnpId.Substring(lBound + <span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">            <span class="keyword">if</span> (!hashResult.Contains(addr))</span><br><span class="line">            &#123;</span><br><span class="line">                hashResult.Add(addr, id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Debug.WriteLine(<span class="string">"Get BT Addr, addr"</span> + addr + <span class="string">" has more than 1 ports"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，WMI 检索也比较耗时，所以这个函数调用需要放入工作线程中执行。</p>
<p>有了这个函数，我们可以通过结果中查找我们设置的蓝牙设备地址，就可以得知对应的虚拟串口名，而如果结果中没有我们设置的蓝牙设备地址，那么就可以认定设置虚拟串口服务失败了。</p>
<h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><p>这里介绍通过配合使用 <code>BackgroundWorker</code> 来实现蓝牙设备的配对、生成虚拟串口的样例代码：</p>
<p>我们通过传入蓝牙设备地址给 worker，worker 在 <code>DoWork</code> 中帮我们处理所有步骤，过程中报告进度，并最终告诉我们结果。</p>
<p>worker 的 <code>DoWork</code> 事件代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进行蓝牙连接操作的后台线程执行函数 */</span></span><br><span class="line"><span class="comment">/* 传入 蓝牙地址字符串 作为参数 */</span></span><br><span class="line"><span class="comment">/* 利用 ReportProgress 报告进度 */</span></span><br><span class="line"><span class="comment">/* 利用 DoWorkEventArgs.Result 报告状态 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgworkerConnection_DoWork</span>(<span class="params"><span class="keyword">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    BackgroundWorker worker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line">    <span class="keyword">string</span> args = e.Argument <span class="keyword">as</span> <span class="keyword">string</span>;</span><br><span class="line">    <span class="keyword">string</span> finalportname = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        BluetoothAddress addr = BluetoothAddress.Parse(args);</span><br><span class="line">        BluetoothDeviceInfo deviceinfo = <span class="keyword">new</span> BluetoothDeviceInfo(addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检测设备是否在服务范围内，有些设备能被发现但不能被配对连接（如果已经被其他终端配对连接） */</span></span><br><span class="line">        <span class="comment">/* 不在范围内则报告错误信息 */</span></span><br><span class="line">        worker.ReportProgress(<span class="number">10</span>, <span class="string">"Testing if device in range..."</span>);</span><br><span class="line">        <span class="keyword">if</span> (!BTHelper.TestIfInRange(addr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> msg = <span class="keyword">string</span>.Format(<span class="string">"Error: Device &#123;0&#125;(&#123;1&#125;) is not reachable!"</span>,</span><br><span class="line">                    deviceinfo.DeviceName,</span><br><span class="line">                    deviceinfo.DeviceAddress.ToString());</span><br><span class="line">            e.Result = msg;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        worker.ReportProgress(<span class="number">10</span>, <span class="string">"Device is in range."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 检测设备是否是已配对设备 */</span></span><br><span class="line">        <span class="keyword">if</span> (deviceinfo.Authenticated)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 已配对设备枚举系统蓝牙串口，检测是否已绑定虚拟串口 */</span></span><br><span class="line">            worker.ReportProgress(<span class="number">10</span>, <span class="string">"Querying Bluetooth serialport..."</span>);</span><br><span class="line">            Hashtable bthTable1 = BTHelper.QueryBTHPorts();</span><br><span class="line">            <span class="keyword">if</span> (bthTable1.ContainsKey(addr.ToString()))</span><br><span class="line">            &#123;   <span class="comment">/* 获取绑定串口 */</span></span><br><span class="line">                finalportname = bthTable1[addr.ToString()] <span class="keyword">as</span> <span class="keyword">string</span>;</span><br><span class="line">                <span class="comment">/* !!! 跳出 !!! */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 此处 else 需考虑枚举结果中没有绑定串口的处理，如果没有绑定串口，那么重新设置串口服务 */</span></span><br><span class="line">            <span class="comment">/* 此处 else 部分会在下面的流程处理，见下方设置串口服务部分 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 需要进行配对 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            worker.ReportProgress(<span class="number">10</span>, <span class="string">"Start pairing..."</span>);</span><br><span class="line">            <span class="keyword">if</span> (!BluetoothSecurity.PairRequest(addr, <span class="string">"1234"</span>))</span><br><span class="line">            &#123;  <span class="comment">/* 配对失败 */</span></span><br><span class="line">                <span class="keyword">string</span> msg = <span class="keyword">string</span>.Format(<span class="string">"Error: Can not pair to Device &#123;0&#125;(&#123;1&#125;)!"</span>,</span><br><span class="line">                        deviceinfo.DeviceName,</span><br><span class="line">                        deviceinfo.DeviceAddress.ToString());</span><br><span class="line">                e.Result = msg;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置串口服务 */</span></span><br><span class="line">        <span class="comment">/* SLC蓝牙设置串口服务时，如果 SetServiceState */</span></span><br><span class="line">        <span class="comment">/* 第三个参数为 true (允许异常) 那么则一定会抛出异常，即使虚拟串口创建成功 */</span></span><br><span class="line">        <span class="comment">/* 所以这里调用2个参数的重载版本 */</span></span><br><span class="line">        <span class="comment">/* 之后检查串口服务是否设置成功的方法就是 设置后检索蓝牙串口 */</span></span><br><span class="line">        worker.ReportProgress(<span class="number">10</span>, <span class="string">"Enable serialport service..."</span>);</span><br><span class="line"></span><br><span class="line">        deviceinfo.SetServiceState(BluetoothService.SerialPort, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 枚举系统蓝牙串口，检查对应蓝牙是否有串口绑定 */</span></span><br><span class="line">        Hashtable bthTable2 = BTHelper.QueryBTHPorts();</span><br><span class="line">        <span class="keyword">if</span> (bthTable2.ContainsKey(addr.ToString()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 获取绑定的串口 */</span></span><br><span class="line">            finalportname = bthTable2[addr.ToString()] <span class="keyword">as</span> <span class="keyword">string</span>;</span><br><span class="line">            <span class="comment">/* !!! 跳出 !!! */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">/* 启用串口服务失败或者无法检测到绑定串口 */</span></span><br><span class="line">            <span class="keyword">string</span> msg = <span class="keyword">string</span>.Format(<span class="string">"Error: Failed to set Serialport service for Device &#123;0&#125;(&#123;1&#125;)!"</span>,</span><br><span class="line">                    deviceinfo.DeviceName,</span><br><span class="line">                    deviceinfo.DeviceAddress.ToString());</span><br><span class="line">            e.Result = msg;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    worker.ReportProgress(<span class="number">10</span>, <span class="string">"Open serialport..."</span>);</span><br><span class="line"></span><br><span class="line">    Debug.WriteLine(<span class="keyword">string</span>.Format(<span class="string">"&gt;&gt;PORT NMAE: &#123;0&#125;"</span>, finalportname));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成功 */</span></span><br><span class="line">    <span class="comment">/* 将串口名放入消息中返回 */</span></span><br><span class="line">    <span class="keyword">string</span> okmsg = <span class="keyword">string</span>.Format(<span class="string">"OK: &#123;0&#125;"</span>, finalportname);</span><br><span class="line">    e.Result = okmsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中通过灵活使用 <code>string</code> 作为 <code>Result</code> 来表明执行结果。</p>
<p>worker 的 <code>RunCompleted</code> 事件代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bgworkerConnection_RunCompleted</span>(<span class="params"><span class="keyword">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> msg = e.Result <span class="keyword">as</span> <span class="keyword">string</span>;</span><br><span class="line">    <span class="keyword">if</span>(msg.StartsWidth(<span class="string">"OK"</span>))</span><br><span class="line">    &#123;   <span class="comment">/* OK */</span></span><br><span class="line">        MessageBox.Show(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  <span class="comment">/* Error */</span></span><br><span class="line">        MessageBox.Show(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续可以通过字符串处理提取出生成的串口名。</p>
<p>worker 的启动代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgworkerConnection.RunWorkerAsync(addrstring);</span><br></pre></td></tr></table></figure>
<p>这样子我们就获取到了绑定的虚拟串口名，但是在使用串口中要注意的是，虚拟串口打开过程中，本质上还是发起了一个蓝牙数据连接，所以打开过程会耗时较长，所以这个虚拟串口打开过程也需要放入工作线程中处理。如果虚拟串口对应的蓝牙设备没有在线或者其他原因造成不可用，那么打开时会抛出异常，需要在代码上进行处理。</p>
<p>一旦蓝牙设备经过绑定并且设置虚拟串口服务成功，那么对应的串口会一直存在与系统的串口列表中，但这并不代表它是可用的，请在打开这类串口时添加异常处理代码。</p>
<p>(完)</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/using-visual-studio-remote-debugger/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 <a href="https://tisyang.github.io">tisyang</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>