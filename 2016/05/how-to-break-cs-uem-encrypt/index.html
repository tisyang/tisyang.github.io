<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 中软统一终端加密文件解密 · 碎片</title><meta name="description" content="中软统一终端加密文件解密 - tisyang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tisyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">中软统一终端加密文件解密</h1><div class="post-time">2016年5月23日</div><div class="post-content"><p>背景不提，通过搜索能看到这篇文章的，请彼此保持同情。</p>
<p>中软统一终端这个软件通过网内文件加密存储，使用时自解密，保证一个局部网络的资料安全性，防止泄漏，主要用于密级文档、源代码和工程图纸的管控。</p>
<p>听起来很高大上，但是在文件加密解密这条策略链上，漏洞是很多的，在具体部署上，漏洞就更多了。下面介绍一下如何利用策略漏洞解密被加密的文件，这里主要针对源代码，其他文档类似。</p>
<a id="more"></a>
<p>首先讲一下中软终端的文件加密解密过程。</p>
<h2 id="加密解密过程"><a href="#加密解密过程" class="headerlink" title="加密解密过程"></a>加密解密过程</h2><p> 安装统一终端后，如果有加密策略部署，程序后台会扫描所有文件，判断文件后缀名或文件类型是否与策略一致来进行加密操作。</p>
<p> 策略中通常会有针对加密文件类型相关软件的白名单，在这个名单中的程序，去处理加密的文件时，会<strong>透明地</strong>读取到解密后的文件，然后再保存该类型的文件时，文件又自动被加密了。如果白名单程序新生成该类型文件，那么文件保存时会自动被加密。</p>
<p>白名单程序的存在是为了保证日常操作，否则都不能用了岂不是因噎废食。</p>
<p>当某类文件被白名单程序读取时，中软终端会自动把加密的文件解密，然后提供给程序。中软是通过文件驱动来实现了这一中间人角色，来桥接加密文件和程序，对于非白名单程序则不提供解密，这样打开就会乱码报错。</p>
<h2 id="策略的漏洞"><a href="#策略的漏洞" class="headerlink" title="策略的漏洞"></a>策略的漏洞</h2><p>这一套“透明地”加密解密的确很不错，但是停下想一想，尤其想一想互联网安全相关的实例，是不是有什么漏洞可破？</p>
<p>互联网安全相关通常都是这个问题：Can I trust you?</p>
<p>白名单是策略的关键，一个程序加入其中就表示对其可信，程序可以读取被加密的文件，这时候鉴权就很重要了。我们来根据实际来分析一下可能的鉴权策略：</p>
<ol>
<li><p>最简单的，根据进程名来判定程序是否归属白名单中。这个方法最简单，也最灵活，部署也很方便，但是，只根据进程名会不会不大可靠？</p>
</li>
<li><p>进阶一点的，根据程序文件 Hash。在部署策略时，将可执行程序文件的 Hash 也加入其中，只有 Hash 匹配才认定程序是归属白名单中。这个是一个不错的方法，但是维护就很麻烦，因为很多程序经常会升级，这时候文件变了 Hash 也变了，策略就不得不更新，而对于一些离线机器得不到策略更新就更悲剧了。</p>
</li>
<li><p>在2的基础上，继续完善，使用程序数字签名验证。程序文件的 Hash 会变，但是经过数字签名那么就可以认定这的确是谁谁谁家的程序。这个方法在终端中应该是被用到的，但肯定不是全部，毕竟只有大公司软件产品才会进行数字签名，比如 word/ppt/excel，可执行程序都是签名过的。而在软件开发中，有相当多开源工具是不可能进行签名的。</p>
</li>
</ol>
<p>通过上述分析，我们可以猜测中软终端使用了方法1和3，而方法1中，只根据进程名判定是一个漏洞，我们可以编写克隆程序来读取加密文件。</p>
<p>读取这边解决了，还需要考虑输出这环节。白名单程序保存文件时会进行加密，但是并不会加密所有文件。因为工具也可能用来处理不重要的事情，或者其他必须不能加密的地方，比如编译代码最终生成可执行程序，可执行程序不能被加密。而这部分通常是根据文件后缀名来判断是否需要被加密的。</p>
<p>所以我们写一个与白名单中同名的程序，读取文件内容并输出到一个不会被加密的格式即可。</p>
<h2 id="例子代码"><a href="#例子代码" class="headerlink" title="例子代码"></a>例子代码</h2><p>因为依赖程序进程名，所以用脚本在这里不合适，最简单可以用 C，一个简单的文件拷贝就可以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    FILE *nfp;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> read;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Invalid args count!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%s.xxx"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    nfp = fopen(buf, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"File not exists!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nfp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Can't create file!\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((read = fread(buf, <span class="number">1</span>, sizeof(buf), fp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        fwrite(buf, <span class="number">1</span>, read, nfp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(nfp);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序接收一个参数，参数为文件名，然后输出一个源文件的拷贝，命名为原文件名 + “.xxx”，这里 “.xxx” 可以选别的易于识别而且不会被加密的就行。</p>
<p>然后根据我们要解密的文件类型（这里以源代码为例），我们可以知道白名单程序中会有哪些程序，比如 IDE 中的 Visual Studio(<code>devenv.exe</code>)， Android Studio(<code>androidstudio.exe</code>)，代码管理程序的 SVN(<code>svn.exe</code>)，等等。</p>
<p>这里以 SVN 作为例子，我们编译程序 <code>gcc -o svn xxx.c</code>，然后就生成了 <code>svn.exe</code> 程序。</p>
<p>在一台安装了统一终端并启用加密的机器上，拷贝 <code>svn.exe</code> 到被加密代码的根目录。现在我们需要批量来解密我们需要的文件。</p>
<p>用 Shift + 右键打开目录的命令行，然后输入 <code>powershell</code> 进入 PowerShell 执行环境，然后输入如下代码</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="variable">$i</span> <span class="keyword">in</span> <span class="built_in">Get-ChildItem</span> -Recurse -Include *.c) &#123; .\svn <span class="variable">$i</span>.FullName &#125;</span><br></pre></td></tr></table></figure>
<p>该代码表示遍历目录下所有（包括子目录，子子目录）以 <code>.c</code> 结尾的文件，然后对其执行 <code>svn</code>，也就是我们写的 <code>svn.exe</code> 程序，<code>FullName</code> 表示使用绝对路径。</p>
<p>该代码只是解密了所有 C 文件，如果需要解密其他文件，则需要再次输入并修改后缀名即可。</p>
<p>PS: 因为 Windows 对于 Powershell 脚本的安全限制，这里并不能写入脚本中用 Powershell 执行，必须手动输入执行。</p>
<p>最后，我们需要把解密的文件的文件名复原，这里使用脚本语言就比较容易了，例如 Ruby， 写一个 <code>rename.rb</code> 放根目录然后执行即可：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dir.glob(<span class="string">"**/*.xxx"</span>) <span class="keyword">do</span> <span class="params">|fname|</span></span><br><span class="line">  File.rename(fname, fname.chomp(<span class="string">".xxx"</span>))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>找出这种漏洞并不是有意为之，而是某些时候这样做反而效率干脆，臃肿的官僚管理和流程太折磨人了，本来这个系统被利用多数也是懒政造就，系统本身带来的负面影响已经盖过了积极意义。机器运行缓慢，加密导致的奇怪问题，开发部署环境不一致的 bug 等等等，而这其中，这个系统部署和维护不够专业及时也加重了消耗。</p>
<p>多点真诚，少点套路。机械依赖工具而不改变思维通常都是徒劳。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/add-exe-to-path/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 <a href="https://tisyang.github.io">tisyang</a>, unless otherwise noted.</p></div></footer></div><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>