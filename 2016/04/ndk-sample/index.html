<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> NDK 实例 · 碎片</title><meta name="description" content="NDK 实例 - tisyang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tisyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">NDK 实例</h1><div class="post-time">2016年4月12日</div><div class="post-content"><p>本文通过编写一个算法类二进制库以及示例App应用来介绍NDK开发，重点是二进制库编写、编译以及自定义参数的传递。</p>
<a id="more"></a>
<h2 id="1-Java层接口定义"><a href="#1-Java层接口定义" class="headerlink" title="1. Java层接口定义"></a>1. Java层接口定义</h2><p>在做so库之前，需要首先设计约定库的接口，包括实现哪些功能，具体函数以及接口参数等等，这也是Java层调用所使用的接口。</p>
<p>在这个例子中，我们准备实现一个算法库，其中实现2个函数，一个返回算法库版本号，另一个计算线段中点坐标，主要用来展示so库编写以及参数传递过程。如果有需要其他的接口实现，可以参照这两个函数来做。</p>
<p>要实现的接口文件 <code>com/zhdgps/ts/TSMath.java</code>，其中 <code>tsmath</code> 是要实现的so库名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhdgps.ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSMath</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.loadLibrary(<span class="string">"tsmath"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取版本信息 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getVersion</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">/* 计算两点连线中心点 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> TSCoord <span class="title">calcCenter</span><span class="params">(TSCoord a, TSCoord b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>System.loadLibrary</code> 用来加载so库，<code>static</code> 表示这段代码要最先运行。</p>
<p>接口函数用 <code>native</code> 关键字修饰表明这是源生方法实现而不是 java 代码实现（JNI），在这里就是指在so库中实现的方法。</p>
<p>同时辅助用的 <code>TSCoord</code> 定义文件 <code>com/zhdgps/ts/TSCoord.java</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhdgps.ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSCoord</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> N;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> E;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">double</span> Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个文件都放属于包 <code>com.zhdgps.ts</code> 。</p>
<h2 id="2-so库C代码实现和编译"><a href="#2-so库C代码实现和编译" class="headerlink" title="2. so库C代码实现和编译"></a>2. so库C代码实现和编译</h2><p>完成库接口设计后，下面介绍如何用C来实现接口对应的功能。</p>
<p>新建文件夹 <code>tsmath</code>，用于存放 so 库工程。在 <code>tsmath</code> 下新建子文件夹 <code>jni</code> （命名为<code>jni</code> 是 NDK 编译的需要）用于存放 so 库的源文件。</p>
<p>在 <code>jni</code> 文件夹下新建文件 <code>tsmath.h</code>、<code>tsmath.c</code>、<code>algorithm.h</code>、<code>algorithm.c</code>、<code>Android.mk</code> 以及 <code>Application.mk</code> 文件。</p>
<p>其中，<code>tsmath.h</code> 和 <code>tsmath.c</code> 是 so 库的实现文件，<code>algorithm.h</code> 和 <code>algorithm.c</code> 是实际算法实现，相对来说 <code>tsmath.c</code> 是 JNI 接口层，而 <code>algorithm.c</code> 则是实际的算法C代码。这样区分有助于代码逻辑分层，当然都写在 <code>tsmath.c</code> 中也是可行的。</p>
<p><code>Android.mk</code> 和 <code>Application.mk</code> 是用于编译so库所需要的 <code>ndk-build</code> 脚本文件，后面会进行详细叙述。</p>
<h3 id="2-1-算法实现（Algorithm）"><a href="#2-1-算法实现（Algorithm）" class="headerlink" title="2.1 算法实现（Algorithm）"></a>2.1 算法实现（<code>Algorithm</code>）</h3><p><code>Algorithm.h</code> 文件内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TS_ALGORITHM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TS_ALGORITHM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _TSCoord &#123;</span><br><span class="line">    <span class="keyword">double</span> N;</span><br><span class="line">    <span class="keyword">double</span> E;</span><br><span class="line">    <span class="keyword">double</span> Z;</span><br><span class="line">&#125;TSCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> TSAlgo_ErrorCode &#123;</span><br><span class="line">    TSALGO_NOERROR,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TSAlgo_CalcCenter</span><span class="params">(<span class="keyword">const</span> TSCoord *a, <span class="keyword">const</span> TSCoord *b, TSCoord *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>头文件主要声明了一个计算中点的函数以及参数结构体类型，实现文件 <code>Algorithm.c</code> 内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"algorithm.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TSAlgo_CalcCenter</span><span class="params">(<span class="keyword">const</span> TSCoord *a, <span class="keyword">const</span> TSCoord *b, TSCoord *result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    result-&gt;N = (a-&gt;N + b-&gt;N) / <span class="number">2</span>;</span><br><span class="line">    result-&gt;E = (a-&gt;E + b-&gt;E) / <span class="number">2</span>;</span><br><span class="line">    result-&gt;Z = (a-&gt;Z + b-&gt;Z) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    return TSALGO_NOERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有其他要实现的算法，都可以在这个模块内实现。此模块将被 JNI 接口层调用。</p>
<h3 id="2-2-JNI-接口实现"><a href="#2-2-JNI-接口实现" class="headerlink" title="2.2 JNI 接口实现"></a>2.2 JNI 接口实现</h3><p>JNI 接口部分是 so 库的核心，用于在 Java 调用和实际的 C/C++ 调用之间充当中间层。JNI 的实现有两种方法，一种是静态注册，一种是动态注册。</p>
<p>静态注册是指用 <code>javah</code> 工具来生成 C/C++ 头文件，获得正确的函数名。在运行时 JNI 按照指定规则的函数命名来调用对应的 C 函数。</p>
<p>动态注册是指在动态库模块被加载的时候，模块注册的函数功能到 JVM 中。在对应函数被调用时，JVM会按照指定的注册函数名去调用实际的函数。</p>
<p>静态注册生成的函数命名很长，而且如果要修改函数名，那么就要重新修改编译。静态注册的模块只有在被调用时才会被查找检查，如果函数命名有问题，会直接运行异常。</p>
<p>动态注册在向 JVM 注册函数时，可以指定函数名，在编写时可以使用自定义的函数命名，如果需要修改维护，则只需要修改注册时的命名即可。</p>
<p>NDK 推荐使用动态注册，在模块中定义 <code>JNI_OnLoad</code> 函数,此函数在模块被加载时（即<code>System.loadLibrary</code>）被调用，模块在此函数中注册所有函数。</p>
<p>综上，我们要在模块中实现3个主要函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 动态库加载时候被调用的方法，进行初始化并注册模块函数 */</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span></span>;</span><br><span class="line"><span class="comment">/* 对应 TSMath.getVersion */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">native_get_version</span><span class="params">(JNIEnv *env, jobject thiz)</span></span>;</span><br><span class="line"><span class="comment">/* 对应 TSMath.calcCenter */</span></span><br><span class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">native_calc_center</span><span class="params">(JNIEnv *env, jobject thiz, jobject coorda, jobject coordb)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>native_get_version</code> 和 <code>native_calc_center</code> 即 <code>TSMath</code> 的 JNI 实现，函数参数和返回值也与之对应，每个函数的前两个参数 <code>JNIEnv *</code> 和 <code>jobject</code> 是 JNI 函数固定传入的参数。<code>jstring</code> 对应 Java 的 <code>String</code>，而自定义类对象均用 <code>jobject</code> 来对应，完整的 JNI 类型匹配可以参见 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/types.html#wp428" target="_blank" rel="external">Primitive Types</a>.</p>
<p>要实现动态注册，我们需要编写注册方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------- */</span></span><br><span class="line"><span class="comment">/* 方法注册资源表 */</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod native_methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"getVersion"</span>, <span class="string">"()Ljava/lang/String;"</span>, (void *)native_get_version&#125;,</span><br><span class="line">    &#123;<span class="string">"calcCenter"</span>, <span class="string">"(Lcom/zhdgps/ts/TSCoord;Lcom/zhdgps/ts/TSCoord;)Lcom/zhdgps/ts/TSCoord;"</span>, (void *)native_calc_center&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NATIVE_METHODS_COUNT (sizeof(native_methods)/sizeof(native_methods[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为某一个类注册方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_navtive_methods</span><span class="params">(JNIEnv *env,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">char</span> *classname,</span><br><span class="line">                                    JNINativeMethod *methods,</span><br><span class="line">                                    <span class="keyword">int</span> methods_num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line">    clazz = (*env)-&gt;FindClass(env, classname);</span><br><span class="line">    <span class="keyword">if</span>(clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((*env)-&gt;RegisterNatives(env, clazz, methods, methods_num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为所有类注册本地方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_natives</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/* 指定要注册的类名 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *classname = <span class="string">"com/zhdgps/ts/TSMath"</span>;</span><br><span class="line">    return register_navtive_methods(env, classname, native_methods, NATIVE_METHODS_COUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JNINativeMethod</code> 是在 <code>&lt;jni.h&gt;</code> 中定义的结构体，用于存储要动态注册的函数信息。第一个成员是字符串，用以表示要注册的函数所使用的函数名。第二个成员是字符串，用以表示函数的参数和返回值接口(<code>Type Signatures</code>)，在这个字符串中，<code>&quot;()&quot;</code>内表示函数的参数类型，然后是函数的返回值类型，<code>&quot;()&quot;</code> 表示函数参数为空，而如果函数返回值为空，则用 <code>&quot;()V&quot;</code> 表示。 <code>&quot;Ljava/lang/String;&quot;</code> 表示为 <code>java.lang.String</code>，<code>&quot;Lxxx;&quot;</code> 是 <code>xxx</code> 类型的完整写法，包字段分隔用斜杠代替，比如 <code>&quot;Lcom/zhdgps/ts/TScoord;&quot;</code> 表示类型为 <code>com.zhdgps.ts.TSCoord</code> 。如果参数有多个，依次写出对应类型。Java 源生类型可以参考 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/types.html#wp16432" target="_blank" rel="external">Type Signatures</a>.</p>
<p>在 <code>register_natives</code> 中，我们将这两个函数注册到了类 <code>com/zhgps/ts/TSmath</code> 中，这个类就是之前在 Java 层定义的 <code>com.zhdgps.ts.TSMath</code>。</p>
<p>下面继续 <code>native_get_version</code> 和 <code>native_calc_center</code> 两个函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TSMATH_VERSION  <span class="string">"v0.1 alpha"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">native_get_version</span><span class="params">(JNIEnv *env, jobject thiz)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return (*env)-&gt;NewStringUTF(env, TSMATH_VERSION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>native_get_version</code> 比较简单，就返回一个版本文本字符串。这里需要注意的是，如果函数需要返回非ASCII的字符串，则不能直接使用 <code>NewStringUTF</code>，因为 JNI 使用了修改版的 UTF-8 编码，具体可以参考 <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/types.html#wp16542" target="_blank" rel="external">Modified UTF-8 Strings</a>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 保存全局 TSCoord 的信息，便于后续检索成员 */</span></span><br><span class="line"><span class="keyword">struct</span> TSCoordJNIInfo &#123;</span><br><span class="line">    <span class="comment">/* ICS 4.0 之后，jclass 可能会变化，所以在获取后，调用 NewGlobalRef 保存引用，然后就不再变化 */</span></span><br><span class="line">    jclass cls;</span><br><span class="line">    <span class="comment">/* ID 一般不会变化 */</span></span><br><span class="line">    jfieldID fid_n;</span><br><span class="line">    jfieldID fid_e;</span><br><span class="line">    jfieldID fid_z;</span><br><span class="line">    jmethodID mid_init;</span><br><span class="line">&#125; g_tscoord_jni;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper_init_tscoord_jniinfo</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jclass cls = (*env)-&gt;FindClass(env, <span class="string">"com/zhdgps/ts/TSCoord"</span>);</span><br><span class="line">    jfieldID fid_n = (*env)-&gt;GetFieldID(env, cls, <span class="string">"N"</span>, <span class="string">"D"</span>);</span><br><span class="line">    jfieldID fid_e = (*env)-&gt;GetFieldID(env, cls, <span class="string">"E"</span>, <span class="string">"D"</span>);</span><br><span class="line">    jfieldID fid_z = (*env)-&gt;GetFieldID(env, cls, <span class="string">"Z"</span>, <span class="string">"D"</span>);</span><br><span class="line">    jmethodID mid_init = (*env)-&gt;GetMethodID(env, cls, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ICS 4.0 之后保存全局引用需要调用此函数，后续需要解除引用，使用函数 DeleteGlobalRef */</span></span><br><span class="line">    cls = (jclass)((*env)-&gt;NewGlobalRef(env, cls));</span><br><span class="line">    g_tscoord_jni.cls = cls;</span><br><span class="line">    g_tscoord_jni.fid_n = fid_n;</span><br><span class="line">    g_tscoord_jni.fid_e = fid_e;</span><br><span class="line">    g_tscoord_jni.fid_z = fid_z;</span><br><span class="line">    g_tscoord_jni.mid_init = mid_init;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">helper_new_tscoord</span><span class="params">(JNIEnv *env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    jobject tscoord = (*env)-&gt;NewObject(env, g_tscoord_jni.cls, g_tscoord_jni.mid_init);</span><br><span class="line">    return tscoord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> TSCoord <span class="title">helper_get_tscoord</span><span class="params">(JNIEnv *env, jobject coord)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    TSCoord res_coord;</span><br><span class="line"></span><br><span class="line">    jdouble n = (*env)-&gt;GetDoubleField(env, coord, g_tscoord_jni.fid_n);</span><br><span class="line">    jdouble e = (*env)-&gt;GetDoubleField(env, coord, g_tscoord_jni.fid_e);</span><br><span class="line">    jdouble z = (*env)-&gt;GetDoubleField(env, coord, g_tscoord_jni.fid_z);</span><br><span class="line"></span><br><span class="line">    res_coord.N = n;</span><br><span class="line">    res_coord.E = e;</span><br><span class="line">    res_coord.Z = z;</span><br><span class="line"></span><br><span class="line">    return res_coord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper_set_tscoord</span><span class="params">(JNIEnv *env, jobject coord, <span class="keyword">const</span> TSCoord *source)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    (*env)-&gt;SetDoubleField(env, coord, g_tscoord_jni.fid_n, source-&gt;N);</span><br><span class="line">    (*env)-&gt;SetDoubleField(env, coord, g_tscoord_jni.fid_e, source-&gt;E);</span><br><span class="line">    (*env)-&gt;SetDoubleField(env, coord, g_tscoord_jni.fid_z, source-&gt;Z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jobject JNICALL <span class="title">native_calc_center</span><span class="params">(JNIEnv *env, jobject thiz, jobject coorda, jobject coordb)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    TSCoord a, b, c;</span><br><span class="line">    jobject obj;</span><br><span class="line"></span><br><span class="line">    a = helper_get_tscoord(env, coorda);</span><br><span class="line">    b = helper_get_tscoord(env, coordb);</span><br><span class="line"></span><br><span class="line">    TSAlgo_CalcCenter(&amp;a, &amp;b, &amp;c);</span><br><span class="line"></span><br><span class="line">    obj = helper_new_tscoord(env);</span><br><span class="line">    helper_set_tscoord(env, obj, &amp;c);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个结构体 <code>struct TSCoordJNIInfo</code> 用于保存 Java 类 <code>com.zhdgps.ts.TSCoord</code> 保存在 JVM 中的信息，包括类句柄、各字段ID（N，E，Z）以及构造函数ID。这些信息到后面获取/设置类对象字段时会用到，用全局结构体保存这些信息是为了效率，对于 <code>FieldID</code> 和 <code>MethodID</code> 来说，一旦类初始化后就不再变化，如果每次需要获取类对象信息时都去调用 <code>GetFieldID</code> 和 <code>GetMethodID</code> ，会给 JVM 带来负担，而且代码也有冗余。这里需要注意的是类句柄，对于 ICS4.0 以后的安卓系统，内存中的句柄可能会因为内存整理而移动，这意味着类句柄是会变化的，需要使用函数 <code>NewGlobalRef</code> 来保证句柄不变。</p>
<p>函数 <code>helper_init_tscoord_jniinfo</code> 用于获取类信息，这个函数需要在 <code>JNI_OnLoad</code> 中调用，保证在函数被调用前初始化全局信息。</p>
<p>函数 <code>helper_new_tscoord</code>、 <code>helper_get_tscoord</code> 和 <code>helper_set_tscoord</code> 是定义的三个辅助函数，用于新建 <code>TSCoord</code> Java 对象、<code>TSCoord</code> Java 对象与 C 结构体互相转换。</p>
<p>如上，要获取一个类对象信息，依次需要使用 <code>FindClass</code> 来获取类句柄，然后通过句柄来获取各个字段的 <code>FieldID</code>，之后就可以通过这些字段 ID 来获取实际的值。<code>com.zhdgps.ts.TSCoord</code> 字段均为 <code>double</code> 所以使用 <code>GetDoubleField</code> 来获取字段值，如果有其他类型，可以以此类推。</p>
<p>函数 <code>native_calc_center</code> 的逻辑就比较简单了，通过转换对象，然后转为调用 <code>Algorithm</code> 中的算法，然后再将结果转换为 Java 对象返回。</p>
<h3 id="2-3-编译-so-库"><a href="#2-3-编译-so-库" class="headerlink" title="2.3 编译 so 库"></a>2.3 编译 so 库</h3><p>编辑 <code>Android.mk</code> 文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(call my-dir)</span></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 架构</span></span><br><span class="line">LOCAL_ARM_MODE := arm</span><br><span class="line"><span class="comment"># 模块名</span></span><br><span class="line">LOCAL_MODULE := tsmath</span><br><span class="line"><span class="comment"># 模块编译源文件</span></span><br><span class="line">LOCAL_SRC_FILES := tsmath.c algorithm.c</span><br><span class="line"><span class="comment"># 模块依赖的库，比如要使用 android log 库</span></span><br><span class="line">LOCAL_LDLIBS := -llog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译为动态库</span></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>这个文件是用于 so 模块的编译，其中模块名为 <code>tsmath</code>，这样编译出的文件会自动加前后缀，输出为 <code>libtsmath.so</code>。源文件部分加上项目使用的所有 C 文件，头文件不必加入其中。如果有依赖的安卓库，则加到 <code>LOCAL_LDLIBS</code> 链接部分。</p>
<p>编辑 <code>Application.mk</code> 文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP_OPTIM := release</span><br></pre></td></tr></table></figure>
<p>这里指定生成 release 版本的 so 库。如果这里如果需要生成其他平台库，则需要设置 <code>APP_ABI</code> 字段。比如要生成全平台，则添加一句 <code>APP_ABI := all</code>，这样会同时生成其他平台（x86 等）。</p>
<p>下载 NDK ，完成安装并设置好系统 <code>Path</code> 变量。下载地址 <a href="http://developer.android.com/ndk/index.html" target="_blank" rel="external">Android NDK</a>.</p>
<p>在 <code>jni</code> 上一级目录 <code>tsmath</code> 下打开命令行，输入命令 <code>ndk-build</code> 进行编译，编译完成后的 so 文件自动会保存到 <code>libs</code> 目录下。</p>
<h2 id="3-so-库的使用"><a href="#3-so-库的使用" class="headerlink" title="3. so 库的使用"></a>3. so 库的使用</h2><p>下面来新建一个 Android 项目来测试一下 so 库。</p>
<p>使用 Android Studio 新建一个 Hello World 项目，这里可以设置项目命名空间为 <code>com.zhdgps.ts</code> 来方便后面的测试。在项目文件夹的 <code>app/src/main</code> 目录下，新建文件夹 <code>jniLibs</code>，然后复制 <code>tsmath/libs</code> 目录下的编译输出到该文件夹中，注意保留 so 库的目录结构，比如 arm 架构编译的为 <code>jniLibs/armeabi/libtsmath.so</code>。将 <code>TSCoord.java</code> 和 <code>TSMath.java</code> 文件复制到 <code>app/src/main/java/com/zhdgps/ts</code> 目录下。Android Studi 会自动将添加的文件加入到工程中。</p>
<p>修改 <code>MainActivity.java</code> 文件， 在 <code>onCreate</code> 中添加测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TSCoord a = <span class="keyword">new</span> TSCoord();</span><br><span class="line">a.N = <span class="number">1.0</span>;</span><br><span class="line">a.E = <span class="number">2.0</span>;</span><br><span class="line">a.Z = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line">TSCoord b = <span class="keyword">new</span> TSCoord();</span><br><span class="line"></span><br><span class="line">b.N = <span class="number">3.0</span>;</span><br><span class="line">b.E = <span class="number">6.0</span>;</span><br><span class="line">b.Z = <span class="number">9.0</span>;</span><br><span class="line"></span><br><span class="line">TSCoord c = TSMath.calcCenter(a, b);</span><br><span class="line">String output = String.format(<span class="string">"A(%f, %f, %f), B(%f, %f, %f) center: (%f, %f, %f)"</span>,</span><br><span class="line">				a.N, a.E, a.Z,</span><br><span class="line">				b.N, b.E, b.Z,</span><br><span class="line">				c.N, c.E, c.Z);</span><br><span class="line"></span><br><span class="line">TextView view = (TextView)findViewById(R.id.message);</span><br><span class="line">view.setText(output);</span><br></pre></td></tr></table></figure>
<p>这里测试了函数 <code>TSMath.calcCenter</code>。编译项目并运行，就可以看到结果了。</p>
<p>源码可以点击这里<a href="/download/ndk_sample.zip">下载</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/03/ndk-build-problem/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 <a href="https://tisyang.github.io">tisyang</a>, unless otherwise noted.</p></div></footer></div><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>