<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Shell中高效分割字符串 · 碎片</title><meta name="description" content="Shell中高效分割字符串 - tisyang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tisyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Shell中高效分割字符串</h1><div class="post-info">2017年1月11日</div><div class="post-content"><p>通常来说，使用 shell 脚本时候不需要太顾及程序的效率性，能完成任务，只要不是太慢，都可以接受。</p>
<p>但在一些特定应用场合，脚本效率也是一个硬性限制，不能耗时太久，比如说，用 shell 来编写一些处理 HTTP 请求的 CGI 程序，脚本的执行效率直接影响了 HTTP 的响应速度。</p>
<p>在 shell 中分割字符串有多种方法，比如利用 awk、cut 工具，还有内置方法，虽然效果相同，但是执行效率差距较大，尤其在处理大数据量上更是显著。</p>
<a id="more"></a>
<p>用 cut 工具分割字符串一般是以下用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -f 指定列序号 -d 指定分隔符</span><br><span class="line">echo $line | cut -f1 -d &apos; &apos;</span><br></pre></td></tr></table></figure>
<p>用 awk 工具分割字符串类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># $1 代表第一列 以此类推</span><br><span class="line"># -F 指定分割符号</span><br><span class="line">echo $line | awk -F &apos; &apos; &#123;&apos;print $1&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>内部方法分割字符串，用的是 <code>IFS</code> 变量和 <code>set</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置分隔符</span><br><span class="line">IFS=&quot; &quot;</span><br><span class="line"># 分割 line</span><br><span class="line">set -- $lin</span><br><span class="line"># $1 代表第一列，以此类推</span><br><span class="line">echo $1</span><br></pre></td></tr></table></figure>
<p>在 shell 脚本中，使用 awk/cut 这些工具在运行时会创建 sub-shell 来运行，相当于 C 语言中的 <code>system</code>/<code>popen</code> 调用，当需要使用的次数比较多时，这种调用会显著降低脚本的执行速度（创建进程是比较昂贵的）。</p>
<p>而使用内置方法则无需调用外部工具，执行起来效率更高，没有额外开销。</p>
<p>以处理 1000 行的空格分割的数字并分别累加为例，其文件内容大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1    25   30  100</span><br><span class="line">2    26   33  102</span><br><span class="line">3    27   36  104</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">999  1023 3024 2096</span><br><span class="line">1000 1024 3027 2098</span><br></pre></td></tr></table></figure>
<p>保存为文件 <code>test.data</code>。然后编写2个测试脚本，<code>split1.sh</code> 和 <code>split2.sh</code>。</p>
<p><code>split1.sh</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">DataFile=&quot;test.data&quot;</span><br><span class="line"></span><br><span class="line">if [ ! -e $DataFile ]; then</span><br><span class="line">	echo &quot;Fail to open file&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">F1=0</span><br><span class="line">F2=0</span><br><span class="line">F3=0</span><br><span class="line">F4=0</span><br><span class="line"># 设置分割符</span><br><span class="line">IFS=&quot; &quot;</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">	[ -z &quot;$line&quot; ] &amp;&amp; continue</span><br><span class="line">	set -- $line</span><br><span class="line"></span><br><span class="line">	F1=$((F1+$1))</span><br><span class="line">	F2=$((F2+$2))</span><br><span class="line">	F3=$((F3+$3))</span><br><span class="line">	F4=$((F4+$4))</span><br><span class="line">done &lt; $DataFile</span><br><span class="line"></span><br><span class="line">echo &quot;F1=$F1&quot;</span><br><span class="line">echo &quot;F2=$F2&quot;</span><br><span class="line">echo &quot;F3=$F3&quot;</span><br><span class="line">echo &quot;F4=$F4&quot;</span><br></pre></td></tr></table></figure>
<p><code>split2.sh</code>文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">DataFile=&quot;test.data&quot;</span><br><span class="line"></span><br><span class="line">if [ ! -e $DataFile ]; then</span><br><span class="line">	echo &quot;Fail to open file&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">F1=0</span><br><span class="line">F2=0</span><br><span class="line">F3=0</span><br><span class="line">F4=0</span><br><span class="line">IFS=&quot; &quot;</span><br><span class="line"></span><br><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">	[ -z &quot;$line&quot; ] &amp;&amp; continue</span><br><span class="line">	l1=$(echo $line | cut -f1 -d &apos; &apos;)</span><br><span class="line">	l2=$(echo $line | cut -f2 -d &apos; &apos;)</span><br><span class="line">	l3=$(echo $line | cut -f3 -d &apos; &apos;)</span><br><span class="line">	l4=$(echo $line | cut -f4 -d &apos; &apos;)</span><br><span class="line"></span><br><span class="line">	F1=$((F1+$l1))</span><br><span class="line">	F2=$((F2+$l2))</span><br><span class="line">	F3=$((F3+$l3))</span><br><span class="line">	F4=$((F4+$l4))</span><br><span class="line">done &lt; $DataFile</span><br><span class="line"></span><br><span class="line">echo &quot;F1=$F1&quot;</span><br><span class="line">echo &quot;F2=$F2&quot;</span><br><span class="line">echo &quot;F3=$F3&quot;</span><br><span class="line">echo &quot;F4=$F4&quot;</span><br></pre></td></tr></table></figure>
<p><code>split1.sh</code>使用内置方法，<code>split2.sh</code>使用 cut 工具来处理。在 shell 中运行程序并用 <code>time</code> 命令监控执行时间，会发现速度对比特别显著。</p>
<p>以本人测试电脑为例，内置方法执行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ time ./split1.sh</span><br><span class="line">F1=500500</span><br><span class="line">F2=524500</span><br><span class="line">F3=1528500</span><br><span class="line">F4=1099000</span><br><span class="line"></span><br><span class="line">real	0m0.045s</span><br><span class="line">user	0m0.024s</span><br><span class="line">sys	0m0.020s</span><br><span class="line"></span><br><span class="line">$ time ./split2.sh</span><br><span class="line">F1=500500</span><br><span class="line">F2=524500</span><br><span class="line">F3=1528500</span><br><span class="line">F4=1099000</span><br><span class="line"></span><br><span class="line">real	0m4.603s</span><br><span class="line">user	0m0.004s</span><br><span class="line">sys	0m0.736s</span><br></pre></td></tr></table></figure>
<p>粗略看出执行速度相差 100 倍左右。</p>
<p>备注：因为要获取各列数据累加，所以在脚本2中，使用了4次 cut 调用，相当于字符串分割了4此，而脚本1中只使用了一次字符串分割，这种策略也显著增加了执行开销。可以通过使用数组返回 cut 结果来避免多次调用，但是这得看 shell 环境是否支持，某些情况下是不支持数组的，比如 busybox 的 <code>sh</code> 环境。</p>
<p>（完）</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/08/freescale-yocto-custom-linux-image/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="https://tisyang.github.io">tisyang</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>