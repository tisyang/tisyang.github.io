<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> apt源arm gcc交叉编译器注意事项 · 碎片</title><meta name="description" content="apt源arm gcc交叉编译器注意事项 - tisyang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tisyang" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">apt源arm gcc交叉编译器注意事项</h1><div class="post-info">2017年9月13日</div><div class="post-content"><p>做嵌入式 Linux 开发时候都需要使用交叉编译工具，这些一般是方案厂商提供，但我们通常也可以使用那些打包好的通用交叉编译工具，比如 Debian 上 apt 也有打包好的 arm 交叉编译工具： <code>gcc-arm-linux-gnueabi</code> 和 <code>gcc-arm-linux-gnueabihf</code>，对应 c++ 版本以 g++ 开头，这两类主要区别在于 CPU 对于浮点的处理上，涉及到 <code>armel</code> 和 <code>armhf</code> 架构的区别，详情参照<a href="https://blogs.oracle.com/jtc/is-it-armhf-or-armel" target="_blank" rel="external">这里</a>，你只需要选择对应开发板的架构工具即可。</p>
<p>由于是 Debian 自己维护更新的包，上述的两个交叉编译工具通常都会更新比较频繁，会支持最新的标准和特性，但是我们的开发板上系统通常都不是最新的，所以在使用时需要注意，否则会出现编译后的程序无法在开发板上运行。</p>
<p>最近在将 <a href="https://github.com/mruby/mruby" target="_blank" rel="external">mruby</a> 应用到嵌入式环境时就遇到这个问题。</p>
<a id="more"></a>
<h2 id="问题和溯因"><a href="#问题和溯因" class="headerlink" title="问题和溯因"></a>问题和溯因</h2><p>将静态链接了 <code>mruby</code> 库的测试程序 mirb 放入嵌入式环境上运行时，提示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mirb: /lib/libc.so.6: version `GLIBC_2.16<span class="string">' not found (required by ./mirb)</span></span><br></pre></td></tr></table></figure>
<p>嵌入式环境没有 2.16 版本以上的 glibc 库，但是理论上测试程序不需要这么高版本的 glibc 库。在嵌入式命令行上用 <code>ldd</code> （有些嵌入式环境可能没有附带这个工具）查看一下可执行文件信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ldd -v mirb</span></span><br><span class="line">./mirb: /lib/libc.so.6: version `GLIBC_2.16<span class="string">' not found (required by ./mirb)</span><br><span class="line">        libm.so.6 =&gt; /lib/libm.so.6 (0x401ed000)</span><br><span class="line">        libc.so.6 =&gt; /lib/libc.so.6 (0x40293000)</span><br><span class="line">        /lib/ld-linux.so.3 (0x401c4000)</span><br><span class="line"></span><br><span class="line">        Version information:</span><br><span class="line">        ./mirb:</span><br><span class="line">                libm.so.6 (GLIBC_2.4) =&gt; /lib/libm.so.6</span><br><span class="line">                libc.so.6 (GLIBC_2.7) =&gt; /lib/libc.so.6</span><br><span class="line">                libc.so.6 (GLIBC_2.16) =&gt; not found</span><br><span class="line"></span><br><span class="line">                libc.so.6 (GLIBC_2.4) =&gt; /lib/libc.so.6</span><br><span class="line">        /lib/libm.so.6:</span><br><span class="line">                ld-linux.so.3 (GLIBC_PRIVATE) =&gt; /lib/ld-linux.so.3</span><br><span class="line">                libc.so.6 (GLIBC_2.4) =&gt; /lib/libc.so.6</span><br><span class="line">        /lib/libc.so.6:</span><br><span class="line">                ld-linux.so.3 (GLIBC_2.4) =&gt; /lib/ld-linux.so.3</span><br><span class="line">                ld-linux.so.3 (GLIBC_PRIVATE) =&gt; /lib/ld-linux.so.3</span></span><br></pre></td></tr></table></figure>
<p>可执行程序 mirb 的确引用 2.16 版本的 glibc 库，那就继续查一下引用了 2.16 版本 glibc 库的哪些符号。</p>
<p>在开发主机（不需要在嵌入式主机中）上可以使用 objdump 工具查看可执行程序的符号表（参数 <code>-t</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -t mirb | grep 2.16</span><br><span class="line">00000000       F *UND*	00000000              timespec_get@@GLIBC_2.16</span><br></pre></td></tr></table></figure>
<p>可以看出是 <code>timespec_get</code> 这个函数符号需要 2.16 版本的 glibc 库，那么就得在代码中查一下哪个地方调用了这个函数。</p>
<p>在<a href="https://github.com/mruby/mruby/blob/stable/mrbgems/mruby-time/src/time.c#L285" target="_blank" rel="external">这里</a> 可以看出 <code>mruby</code> 源码的 <code>time.c</code> 文件中使用了 <code>timespec_get</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  tm = (struct mrb_time *)mrb_malloc(mrb, sizeof(*tm));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(TIME_UTC)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> timespec ts;</span><br><span class="line">    <span class="keyword">if</span> (timespec_get(&amp;ts, TIME_UTC) == <span class="number">0</span>) &#123;</span><br><span class="line">      mrb_free(mrb, tm);</span><br><span class="line">      mrb_raise(mrb, E_RUNTIME_ERROR, <span class="string">"timespec_get() failed for unknown reasons"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tm-&gt;sec = ts.tv_sec;</span><br><span class="line">    tm-&gt;usec = ts.tv_nsec / <span class="number">1000</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(NO_GETTIMEOFDAY)</span></span><br></pre></td></tr></table></figure>
<p>宏定义 <code>TIME_UTC</code> 控制着代码是否调用 <code>timespec_get</code> 函数。</p>
<p>通过<a href="http://en.cppreference.com/w/c/chrono/timespec_get" target="_blank" rel="external">搜索</a>了解到，<code>TIME_UTC</code> 和 <code>timespec_get</code> 都是 C11 标准里定义的。由于在编译 <code>mruby</code> 时没有指定编译参数，交叉编译工具使用了默认参数导致 C11 标准也被支持，<code>mruby</code> 库也就使用了最新的 C11 标准，引用了新函数 <code>timespec_get</code>，产生了 glibc 2.16 版本的依赖。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在知晓原因后，解决方法就简单了。就是在交叉编译 <code>mruby</code> 库时，去指定编译标准（c标准），修改 <code>mruby</code> 的编译配置文件 <code>build_config.rb</code> ：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conf.cc <span class="keyword">do</span> <span class="params">|cc|</span></span><br><span class="line">    cc.command = <span class="string">"arm-linux-gnueabi-gcc"</span></span><br><span class="line">    cc.flags &lt;&lt; <span class="string">"-std=gnu99"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>将编译 c 标准指定为 gnu99（<code>-std=gnu99</code>），这里也可以使用 c99 标准（<code>-std=c99</code>）。</p>
<p>然后重新编译测试程序，放到嵌入式环境上运行，OK。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>使用编译器尤其是交叉编译器时，最好要指定编译参数，确定编译标准，否则目标平台可能不支持，导致程序无法运行。在向第三方提供开发库而不是源码的情况下， 需要特别注意，尽量使用统一的编译参数标准，推荐 c99 或者 gnu99。</p>
<p>在遇到类似 <code>/lib/libc.so.6: version GLIBC_X.XX not found</code> 问题时，可以借助 <code>ldd</code> 和 <code>objdump</code> 工具来确定依赖的符号源，寻找解决方法。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/10/linux-shell-tips/" class="prev">PREV</a><a href="/2017/08/cmake-project-layout/" class="next">NEXT</a></div><div class="copyright"><p>© 2016 - 2017 <a href="https://tisyang.github.io">tisyang</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>